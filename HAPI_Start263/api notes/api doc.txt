Displaying Text
For basic text you can use the defaults like so:

HAPI.RenderText(50,400,HAPI_TColour(255,0,0),”Some Red Text”);
If you want to control the size and / or style flags you can provide extra parameters. The following displays larger text and in bold and italic:

HAPI.RenderText(50,400,HAPI_TColour(255),”Some Large Bold Italic Text”, 40, eBold | eItalic);
Note: the style flags can be or’d together to make different combinations.

You can also set a different fill colour for the text to its border colour:

HAPI.RenderText(0,0,HAPI_TColour::BLACK,HAPI_TColour::WHITE, 2, ”Outlined Text”, 22);
GetTextSize is available so you can tell in advance the size of text to be rendered. See

<a href="./reference.html">reference</a>
.
Handling Input
HAPI provides three functions for determining user input, they are

<a href="./reference.html#GetKeyboardData">GetKeyboardData</a>
(),
<a href="./reference.html#GetMouseData">GetMouseData</a>
() and
<a href="./reference.html#GetControllerData">GetControllerData</a>
(). Each one returns a HAPI structure that contains member variables that you can read.
To read the keyboard:
const HAPI_TKeyboardData &keyData = HAPI.GetKeyboardData();
if (keyData.scanCode[‘V’)
    // V key pressed
if (keyData.scanCode[HK_DOWN])
    // Down arrow pressed
For alpha numeric input you can just use the character in single quotes as the index into the scanCode array. For the special keys HAPI provides some defines (in HAPI_InputCodes.h) for example HK_END, HK_HOME, HK_TAB etc.

To read the mouse:
const HAPI_TMouseData &mouseData = HAPI.GetMouseData();
if (mouseData.leftButtonDown)
    std::cout << “Mouse button is down and mouse is located at: “ << mouseData.x <<
         ”,“ << mouseData.y << std::endl
The returned structure has members for x, y screen position, wheel movement, and states of all the buttons

To read the controller:
To read the controller is slightly different as unlike the keyboard and mouse it is not guaranteed to be attached and may even be unattached and attached again during the game so you need to keep checking. To support this the controller data structure has a member called isAttached that you need to check. If this is false the other data is not valid. In addition when getting controller data you need to say which controller. There can be many controllers attached. The id starts from 0. So to test if the first controller is attached and then read data:

const HAPI_TControllerData& data = HAPI.GetControllerData(i);

if (data.isAttached)
{
    Now you can read the data
}
The controller data structure contains member arrays for digital buttons and for analogue buttons. Since HAPI supports many different controllers how many of each there are is dependant on the hardware but there is a maximum of HAPI_MAX_BUTTON_ARRAY_SIZE. The HAPI_InputCodes.h file contains some helper defines that match with the XBox controller. There are 14 digital buttons on the XBox controller and 6 analogue controls. So:

if (data.digitalButtons[HK_DIGITAL_DPAD_DOWN]
    // DPAD down digital button pressed
int value=data.analogueButtons[HK_ANALOGUE_LEFT_TRIGGER];
    // Now value has a value representing how much the left trigger is pressed
Note: controllers always have a dead zone. Due to the electronics involved with analogue controllers you get spurious values near 0 i.e. they do not always return to 0. So you need to ignore values below a certain amount. Microsoft provides guideline values for the XBox controller and these are in HAPI_InputCodes as defines e.g. HK_GAMEPAD_LEFT_THUMB_DEADZONE

Sound
HAPI makes a distinction between streamed media (that is buffered from the disk) and media that is fully loaded into ram. Normally for sound effects etc. you load them into ram but video and music files tend to be much larger and so are streamed.

To load a sound and play it all in one call:

if (!HAPI.PlaySound(“drum.wav”))
     // Error occurred, probably the sound file could not be found
Note: the file must be in the working directory. If you are developing in Visual Studio the working directory is set to where the Visual Studio project file is (.vcxproj). If you are running an executable directly then the working directory is where the executable is located.

Note: HAPI supports most sound file formats but there are some obscure formats that can fail

To preload a sound:

This allows you to load sounds prior to the game loop so you do not suffer glitches from file operations occurring

if (!HAPI.LoadSound(“drum.wav”))
     // Error occurred, probably the sound file could not be found
You can also optionally provide a HAPI_TSoundOptions instance which allows you to set a sound’s pan, volume, loop, pitch modification and even provide a 3D position for the sound.

To play a sound panned fully to the left that loops and is  at half volume:

HAPI_TSoundOptions options(0.5f,true,-1);
if (!HAPI.PlaySound(“drum.wav”,options))
    // Error
In addition you can alter a playing sound as it is playing so for example if you had the sound of a car engine you could change its pitch to represent acceleration and also move it across the stereo field. To do this you use the ChangePlayingSoundOptions call.

You can also stop or pause a sound by calling StopSound and check its status by calling GetSoundStatus. These functions require you know which playing sound to query so when playing a sound you need to get the instance id (the third parameter returned from PlaySound)

e.g.

int instanceId;
HAPI_TSoundOptions options(0.5f,true,-1);
if (!HAPI.PlaySound(“drum.wav”,options,instanceId)
      // error
// Later on to stop it:
HAPI.StopSound(instanceId);
Advanced: HAPI provides some functions to manipulate the sound data itself. These are CreateSound, GetSoundRawData and SetSoundRawData. These will be demonstrated in a lecture.

Music & Video
Due to the size of music and video files these are streamed from the hard drive. e.g.

if (!PlayStreamedMedia(“brilliantMusic.mp3”)
     // Error occurred, probably the file could not be found

if (!PlayStreamedMedia(video.mpg”)
     // Error occurred, probably the file could not be found

You can also provide a set of options when playing back via the HAPI_TStreamedMediaOptions structure. You can control volume, start offset, loop mode and (for video only) sizing, screen position and dimensions and ratio preservation.

Displaying a User Message
HAPI provides a function to put up a modal dialog box with a message and some buttons. Modal means the rest of the program is paused until the user closes the dialog. The prototype is:

bool UserMessage(const std::string &text,const std::string& title, 
    HAPI_ButtonType buttonType=eButtonTypeOk,,HAPI_UserResponse *userResponse=0)
There are a number of optional parameters but a minimum call to put up a dialog with a message and title and OK button would be:

HAPI.UserMessage(“File Not Found!”, “Error”);
If you want to change which buttons are included on the dialog you can do so via the third parameter. Options for this are:

eButtonTypeOk    display an OK button only
eButtonTypeOkCancel    display OK and CANCEL buttons
eButtonTypeYesNo    display YES and NO buttons
eButtonTypeYesNoCancel    display YES, NO and CANCEL buttons
With more than one button option you will probably want to find out which button the user pressed. To do this you pass the function a HAPI_UserResponse instance which can then be tested e.g.

HAPI_UserResponse response;
HAPI.UserMessage(“Do you really want to exit the program?”, “Exit?”,
    HAPI_ButtonType::eButtonTypeYesNo,&response);
if (response==HAPI_UserResponse::eUserResponseYes)
    // exit program
Loading a Texture
HAPI supports most texture file formats but it is best to choose a format that includes an alpha channel like tga or png. The LoadTexture function requires that you pass in a BYTE pointer so that it can point that pointer at the memory block for the texture. Note: HAPI converts all textures into 32 bit RGBA format (like the screen). A simple example:

BYTE *textureData;
int texWidth,texHeight;
if (!HAPI.LoadTexture(“myTexture.png”&textureData,texWidth,texHeight)
     // Error - probably the texture could not be found
Note: HAPI looks in the working directory for the texture. For more info see the

<a href="./faq.html">FAQ</a>
.
Note: you are responsible for deleting the memory when you have finished with it e.g.
delete []textureData;
File Open and Save Dialogs
HAPI provides a function to allow you to get filenames from the user using the common Windows file dialog. When working with a file dialog you need to specify file filters and place them in a vector of HAPI_TFileDialogFilters, one for each file type. A filter contains a file type name and a wild card extension e.g. “Text Files”, “*.txt”

So if you wanted the user to select from Bitmaps, Targa and all file formats you would do the following

std::vector<HAPI_TFileDialogFilters> filters;
filters.push_back(HAPI_TFileDialogFilters(“Bitmap Files”, “*.bmp”});
filters.push_back(HAPI_TFileDialogFilters(“Targa Files”, “*.bmp”});
filters.push_back(HAPI_TFileDialogFilters(“All Files”, “*.*”});
In a similar way to the user message function you also need to know what the user response was when closing the dialog as they may have cancelled it. To get this information you pass in an instance of a HAPI_UserResponse enum. You also need to pass in a string that willl have the user chosen filename in it once the dialog is closed.

std::string filename;
HAPI_UserResponse response;
Finally The FileDialog call takes a Boolean flag as the second parameter determining if it is a open file dialog (true) or a save dialog (false).

HAPI.FileDialog(filters, true, filename, response);
if (response !=HAPI_UserResponse::eUserResponseCancel)
{
    // open file with filename
XML File Handling
HAPI includes support for loading, manipulating and saving XML files. You really need to have a working knowledge of XML but a brief explanation is given below.

XML is a file format that aims to represent content in a user readable way as well as a machine readable way. It is a mark-up language like HTML but where the tags are user defined rather than predefined.

XML stores data in nodes with attributes. There are a few types of node but the most common one is the element node. Each node may also have a number of attributes which is where the data is held. Nodes can be children of other nodes so the XML representation is in the form of a tree structure. The top level node is a document node and is otherwise empty.

HAPI provides XML support via a CHapiXML class (defined in HAPI_Types.h). It uses the programming idiom known as RAI I (Resource Acquisition Is Initialization) so you either instantiate an instance by loading an existing XML file or via your own node structure for saving. For example if you wanted to load an XML file you could simply do this:

CHapiXML xml(“SomeFile.xml”);
When HAPI loads an XML file it creates its own internal representation of it using the following structures (defined in HAPI_Types.h):

CHapiXMLNode - this contains node data as well as pointers to any child nodes (the tree) and a collection of attributes. It provides functions to get attributes by name as well as tree accessors.
CHapiXMLAttribute - has the name of an attribute plus some data. The data can be read as various types.
Note: HAPI manages all the XML memory allocation and deletion

XML File Loading & Reading
Example 1: Reading a high score table

You may have an XML file that lists high scores for your game. It may have a root node called HighScoresTable followed by a set of child nodes for each high score called HighScore. Each of these nodes may have an attribute for the score. The file will then look something like:

<HighScoresTable>
    <HighScore name=”Keith” score=”9856777””/>
    <HighScore name=”Petra” score=”1000301””/>
    <HighScore name=”Jeff” score=”98765”/>
    <HighScore name=”Sue” score=”3456””/>
    <HighScore name=”Bob” score=”100””/>
</HighScoresTable>
 

Once loaded you could then extract all the high scores by calling a function that returns all the nodes matching a name.

CHapiXML xml(“HighScores.xml”);
std::vector<CHapiXMLNode*> nodes=xml.GetAllNodesWithName(“HighScore”);

// Output them
for (auto node : nodes)
{
    CHapiXMLAttribute attribute;
    if (!node->GetAttributeWithName("name",attribute))
        return; // somethign went wrong
    HAPI.DebugText(“Player name= “+attribute.AsString())

    if (!node->GetAttributeWithName(“score”,attribute))
        return; // somethign went wrong
    HAPI.DebugText(“Score= “+attribute.AsString())
;
}
From version 2.2.0 the get nodes calls provide an optional node pointer as the starting point for the search, so they will only return matching nodes below that node.

Example 2: Reading an image format

A more complex example can be downloaded here:

<a href="./XML-Handling.zip">XML Handling.zip</a>
. This shows how to load an XML file which describes a large texture sprite sheet and where each sub texture is within it.
XML Creation & Saving
HAPI also provides support for creating your own XML data and saving it. To do this you need to create nodes and attributes and build them into a tree before instantiating a CHapiXML class with a pointer to your root node.
Example 3: Creating the high score table from example 1
The root node should be called HighScoresTable and has no other data, we can create this like so:

// Empty parent node
CHapiXMLNode *rootNode = new CHapiXMLNode("HighScoresTable");
Now we need to add child nodes for each high score, I am just showing 1 here but a full listing is shown later

CHapiXMLNode *highScore = new CHapiXMLNode("HighScore");
Now the HighScore node needs two attributes, one with the name of the player and one with their score, so we create and add these (note: you do not need to allocate memory this time).

// Add Attribute for name
CHapiXMLAttribute nameAttribute("name", “Keith”);
highScore->AddAttribute(nameAttribute);

// Add Attribute for score
CHapiXMLAttribute scoreAttribute("score", ”9856777”);
highScore->AddAttribute(scoreAttribute);
We now want to add this node as a child of the root:

// Add node to tree as child of the root
rootNode->AddChild(highScore);
Once you have added all the names and their scores (you would likely loop through some array to do this) you can create the HAPI XML class and save the file, like so:

// Now save it by creating a CHapiXML instance with our root node
CHapiXML xml(rootNode);
if (!xml.Save("HighScores.xml"))
    HAPI.DebugText("Something went wrong");
Full source code for example 3

struct THighScore
{
    std::string name;
    int score;
};

const THighScore kHighScores[5] =
{
    "Keith",9856777,
    "Petra",1000301,
    "Jeff",98765,
    "Sue",3456,
    "Bob",100
};

void HAPI_Main()
{
   int screenWidth{ 1024 };
   int screenHeight{ 768 };

   if (!HAPI.Initialise(screenWidth, screenHeight, "XML Creation"))
       return;

    // Empty parent node
   CHapiXMLNode *rootNode = new CHapiXMLNode("HighScoresTable");

    // The high scores read from the array above
   for (int i = 0; i < 5; i++)
   {
      CHapiXMLNode *highScore = new CHapiXMLNode("HighScore");

      // Add Attribute for name
      CHapiXMLAttribute nameAttribute("name", kHighScores[i].name);
      highScore->AddAttribute(nameAttribute);

      // Add Attribute for score
      CHapiXMLAttribute scoreAttribute("score", std::to_string(kHighScores[i].score));
      highScore->AddAttribute(scoreAttribute);

      // Add node to tree as child of the root
      rootNode->AddChild(highScore);
   }

   // Now save it by creating a CHapiXML instance with our root node
   CHapiXML xml(rootNode);
   if (!xml.Save("HighScores.xml"))
   HAPI.DebugText("Something went wrong");

   // As a test load it back in and debug output the structure
   CHapiXML xmlLoad("HighScores.xml");
   xmlLoad.DebugOutputStructure();
}
 
This produces the file HighScores.xml:

<?xml version="1.0"?>
<HighScoresTable>
    <HighScore name="Keith" score="9856777" />
    <HighScore name="Petra" score="1000301" />
    <HighScore name="Jeff" score="98765" />
    <HighScore name="Sue" score="3456" />
    <HighScore name="Bob" score="100" />
</HighScoresTable>
 
<img id="SiteStyleLine1" height="11" width="900" src="./line.png" alt="">